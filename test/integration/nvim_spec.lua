require('test.asserts')
local Nvim = require('nvim.nvim')

describe('#integration #Nvim test', function()
  local nvim, eq, eq_err, eq_items
  before_each(function()
    nvim = Nvim.new_from_process()
    eq = function(...) 
      local arg = {...}
      return assert.equal(unpack(arg)) end
    eq_err = function(expected_err, _, err)
      return assert.equal(expected_err, err) 
    end
    eq_items = function(expected, res, i_mode, kv_mode) return 
      assert.contains_same_items(expected, res, i_mode, kv_mode)
    end
  end)
  describe('#Buffer', function()
    local buffer
    before_each(function()
      buffer = nvim.get_current_buffer()
    end)
    it('can return current_buffer', function()
      assert.starts_with(tostring(buffer), 'Buffer%[nvim ext type%]:')
    end)

    describe('line_count, insert and del_line', function()
      it('line_count, insert and del_line', function()
        eq(buffer:line_count(), 1)
        buffer:insert(-1, {'line'})
        eq(buffer:line_count(), 2)
        buffer:insert(-1, {'line'})
        eq(buffer:line_count(), 3)
        buffer:del_line(-1)
        eq(buffer:line_count(), 2)
        buffer:del_line(-1)
        buffer:del_line(-1)
        -- There's always at least one line
        eq(buffer:line_count(), 1)
      end)
    end)

    describe('{get,set,del}_line', function()
      it('works', function()
        eq('', buffer:get_line(0))    
        buffer:set_line(0, 'line1')
        eq('line1', buffer:get_line(0))
        buffer:set_line(0, 'line2')
        eq('line2', buffer:get_line(0))
        buffer:del_line(0)
        eq('', buffer:get_line(0))    
      end)

      it('get_line: out-of-bounds is an error', function()
        buffer:set_line(0, 'line1.a')
        local _, err = buffer:get_line(1)
        eq('Index out of bounds', err)
        _, err = buffer:get_line(-2)
        eq('Index out of bounds', err)
      end)

      it('set_line, del_line: out-of-bounds is an error', function()
        buffer:set_line(0, 'line1.a')
        eq_err('Index out of bounds', buffer:set_line(1, 'line1.b'))
        eq_err('Index out of bounds', buffer:set_line(-2, 'line1.b'))
        eq_err('Index out of bounds', buffer:del_line(2))
        eq_err('Index out of bounds', buffer:del_line(-3))
      end)

      it('can handle NULs', function()
        buffer:set_line(0, 'ab\0cd')
        eq('ab\0cd', buffer:get_line(0))
      end)
    end)

    describe('{get,set}_line_slice', function()
      it('works', function()
        eq_items({''}, buffer:get_line_slice(0, -1, true, true))
        -- Replace buffer
        buffer:set_line_slice(0, -1, true, true, {'a', 'b', 'c'})
        eq_items({'a', 'b', 'c'}, buffer:get_line_slice(0, -1, true, true))
        eq_items({'b', 'c'}, buffer:get_line_slice(1, -1, true, true))
        eq_items({'b'}, buffer:get_line_slice(1, 2, true, false))
        eq_items({}, buffer:get_line_slice(1, 1, true, false))
        eq_items({'a', 'b'}, buffer:get_line_slice(0, -1, true, false))
        eq_items({'b'}, buffer:get_line_slice(1, -1, true, false))
        eq_items({'b', 'c'}, buffer:get_line_slice(-2, -1, true, true))
        buffer:set_line_slice(1, 2, true, false, {'a', 'b', 'c'})
        eq_items({'a', 'a', 'b', 'c', 'c'}, buffer:get_line_slice(0, -1, true, true))
        buffer:set_line_slice(-1, -1, true, true, {'a', 'b', 'c'})
        eq_items({'a', 'a', 'b', 'c', 'a', 'b', 'c'},
          buffer:get_line_slice(0, -1, true, true))
        buffer:set_line_slice(0, -3, true, false, {})
        eq_items({'a', 'b', 'c'}, buffer:get_line_slice(0, -1, true, true))
        buffer:set_line_slice(0, -1, true, true, {})
        eq_items({''}, buffer:get_line_slice(0, -1, true, true))
      end)

      it('get_line_slice: out-of-bounds return empty array', function()
        buffer:set_line_slice(0, 0, true, true, {'a', 'b', 'c'})
        eq_items(
          {'a','b','c'},
          buffer:get_line_slice(0, 2, true, true))
    
        eq_items({'c'}, buffer:get_line_slice(-1, 4, true, true))
        eq_items({'a', 'b', 'c'}, buffer:get_line_slice(0, 5, true, true))
        buffer:set_line_slice(4, 5, true, true, {'d'})
        eq_items({'a', 'b', 'c', 'd'}, buffer:get_line_slice(0, 5, true, true))
        buffer:set_line_slice(-4, -5, true, true, {'e'})
        eq_items({'e', 'a', 'b', 'c', 'd'}, buffer:get_line_slice(0, 5, true, true))
      end)
    end)

    describe('{get,set}_lines', function()
      it('has correct line_count when inserting and deleting', function()
        eq(1, buffer:line_count())
        buffer:set_lines(-1, -1, true, {'line'})
        eq(2, buffer:line_count())
        buffer:set_lines(-1, -1, true, {'line'})
        eq(3, buffer:line_count())
        buffer:set_lines(-2, -1, true, {})
        eq(2, buffer:line_count())
        buffer:set_lines(-2, -1, true, {})
        buffer:set_lines(-2, -1, true, {})
        -- There's always at least one line
        eq(1, buffer:line_count())
      end)

      it('can get, set and delete a single line', function()
        eq_items({''}, buffer:get_lines(0, 1, true))
        buffer:set_lines(0, 1, true, {'line1'})
        eq_items({'line1'}, buffer:get_lines(0, 1, true))
        buffer:set_lines(0, 1, true, {'line2'})
        eq_items({'line2'}, buffer:get_lines(0, 1, true))
        buffer:set_lines(0, 1, true, {})
        eq_items({''}, buffer:get_lines(0, 1, true))
      end)

      it('can get a single line with strict indexing', function()
        buffer:set_lines(0, 1, true, {'line1.a'})
        eq(1, buffer:line_count()) -- sanity
        eq_err('Index out of bounds', buffer:get_lines(1, 2, true))
        eq_err('Index out of bounds', buffer:get_lines(-3, -2, true))
      end)

      it('can get a single line with non-strict indexing', function()
        buffer:set_lines(0, 1, true, {'line1.a'})
        eq(1, buffer:line_count()) -- sanity
        eq_items({}, buffer:get_lines(1, 2, false))
        eq_items({}, buffer:get_lines(-3, -2, false))
      end)

      it('can set and delete a single line with strict indexing', function()
        buffer:set_lines(0, 1, true, {'line1.a'})
        eq_err('Index out of bounds', buffer:set_lines(1, 2, true, {'line1.b'}))
        eq_err('Index out of bounds', buffer:set_lines(-3, -2, true, {'line1.c'}))
        eq_items({'line1.a'}, buffer:get_lines(0, -1, true))
        eq_err('Index out of bounds', buffer:set_lines(1, 2, true, {}))
        eq_err('Index out of bounds', buffer:set_lines(-3, -2, true, {}))
        eq_items({'line1.a'}, buffer:get_lines(0, -1, true))
      end)

      it('can set and delete a single line with non-strict indexing', function()
        buffer:set_lines(0, 1, true, {'line1.a'})
        buffer:set_lines(1, 2, false, {'line1.b'})
        buffer:set_lines(-4, -3, false, {'line1.c'})
        eq_items({'line1.c', 'line1.a', 'line1.b'}, buffer:get_lines(0, -1, true))
        buffer:set_lines(3, 4, false, {})
        buffer:set_lines(-5, -4, false, {})
        eq_items({'line1.c', 'line1.a', 'line1.b'}, buffer:get_lines(0, -1, true))
      end)

      it('can handle NULs', function()
        buffer:set_lines(0, 1, true, {'ab\0cd'})
        eq_items({'ab\0cd'}, buffer:get_lines(0, -1, true))
      end)

      it('works with multiple lines', function()
        eq_items({''}, buffer:get_lines(0, -1, true))
        -- Replace buffer
        for _, mode in pairs({false, true}) do
          buffer:set_lines(0, -1, mode, {'a', 'b', 'c'})
          eq_items({'a', 'b', 'c'}, buffer:get_lines(0, -1, mode))
          eq_items({'b', 'c'}, buffer:get_lines(1, -1, mode))
          eq_items({'b'}, buffer:get_lines(1, 2, mode))
          eq_items({}, buffer:get_lines(1, 1, mode))
          eq_items({'a', 'b'}, buffer:get_lines(0, -2, mode))
          eq_items({'b'}, buffer:get_lines(1, -2, mode))
          eq_items({'b', 'c'}, buffer:get_lines(-3, -1, mode))
          buffer:set_lines(1, 2, mode, {'a', 'b', 'c'})
          eq_items({'a', 'a', 'b', 'c', 'c'}, buffer:get_lines(0, -1, mode))
          buffer:set_lines(-2, -1, mode, {'a', 'b', 'c'})
          eq_items({'a', 'a', 'b', 'c', 'a', 'b', 'c'},
            buffer:get_lines(0, -1, mode))
          buffer:set_lines(0, -4, mode, {})
          eq_items({'a', 'b', 'c'}, buffer:get_lines(0, -1, mode))
          buffer:set_lines(0, -1, mode, {})
          eq_items({''}, buffer:get_lines(0, -1, mode))
        end
      end)

      it('can get line ranges with non-strict indexing', function()
        buffer:set_lines(0, -1, true, {'a', 'b', 'c'})
        eq_items({'a', 'b', 'c'}, buffer:get_lines(0, -1, true)) --sanity

        eq_items({}, buffer:get_lines(3, 4, false))
        eq_items({}, buffer:get_lines(3, 10, false))
        eq_items({}, buffer:get_lines(-5, -5, false))
        eq_items({}, buffer:get_lines(3, -1, false))
        eq_items({}, buffer:get_lines(-3, -4, false))
      end)

      it('can get line ranges with strict indexing', function()
        buffer:set_lines(0, -1, true, {'a', 'b', 'c'})
        eq_items({'a', 'b', 'c'}, buffer:get_lines(0, -1, true)) --sanity

        eq_err('Index out of bounds', buffer:get_lines(3, 4, true))
        eq_err('Index out of bounds', buffer:get_lines(3, 10, true))
        eq_err('Index out of bounds', buffer:get_lines(-5, -5, true))
        -- empty or inverted ranges are not errors
        eq_items({}, buffer:get_lines(3, -1, true))
        eq_items({}, buffer:get_lines(-3, -4, true))
      end)

      it('set_line_slice: out-of-bounds can extend past end', function()
        buffer:set_lines(0, -1, true, {'a', 'b', 'c'})
        eq_items({'a', 'b', 'c'}, buffer:get_lines(0, -1, true)) --sanity

        eq_items({'c'}, buffer:get_lines(-2, 5, false))
        eq_items({'a', 'b', 'c'}, buffer:get_lines(0, 6, false))
        eq_err('Index out of bounds', buffer:set_lines(4, 6, true, {'d'}))
        buffer:set_lines(4, 6, false, {'d'})
        eq_items({'a', 'b', 'c', 'd'}, buffer:get_lines(0, -1, true))
        eq_err('Index out of bounds', buffer:set_lines(-6, -6, true, {'e'}))
        buffer:set_lines(-6, -6, false, {'e'})
        eq_items({'e', 'a', 'b', 'c', 'd'}, buffer:get_lines(0, -1, true))
      end)
    end)

    describe('{get,set,del}_var', function()
      it('works', function()
        buffer:set_var('lua', {1, 2, {['3'] = 1}})
        eq_items({1, 2, {['3'] = 1}}, buffer:get_var('lua'))
        eq_items({1, 2, {['3'] = 1}}, nvim.eval('b:lua'))
        eq(1, nvim.call_function('exists', {'b:lua'}))
        buffer:del_var('lua')
        eq(0, nvim.call_function('exists', {'b:lua'}))
      end)
    end)

    describe('{get,set}_option', function()
      it('works', function()
        eq(8, buffer:get_option('shiftwidth'))
        buffer:set_option('shiftwidth', 4)
        eq(4, buffer:get_option('shiftwidth'))
        -- global-local option
        buffer:set_option('define', 'test')
        eq('test', buffer:get_option('define'))
        -- Doesn't change the global value
        eq([[^\s*#\s*define]], nvim.get_option('define'))
      end)
    end)

    describe('{get,set}_name', function()
      it('works', function()
        nvim.command('new')
        local new_buffer = nvim.get_current_buffer()
        eq('', new_buffer:get_name())
        local new_name = nvim.eval('resolve(tempname())')
        new_buffer:set_name(new_name)
        eq(new_name, new_buffer:get_name())
        nvim.command('w!')
        local f = io.open(new_name)
        assert.is_not_nil(f)
        f:close()
        os.remove(new_name)
      end)
    end)

    describe('is_valid', function()
      it('works', function()
        nvim.command('new')
        local b = nvim.get_current_buffer()
        assert.is_true(b:is_valid())
        nvim.command('bw!')
        assert.is_true(not b:is_valid())
      end)
    end)

    describe('get_mark', function()
      it('works', function()
        buffer:insert(-1, {'a', 'bit of', 'text'})
        local win = nvim.get_current_window()
        win:set_cursor({3, 4})
        nvim.command('mark V')
        eq_items({3, 0}, buffer:get_mark('V'))
      end)
    end)
  end)
  describe('#Tabpage', function()
    describe('get_windows and get_window', function()
      it('works', function()
        nvim.command('tabnew')
        nvim.command('vsplit')
        local tab1, tab2 = unpack(nvim.get_tabpages())
        local win1, win2, win3 = unpack(nvim.get_windows())
        eq_items({win1},  tab1:get_windows())
        eq_items({win2, win3},  tab2:get_windows())
        eq(win2, tab2:get_window())
        nvim.set_current_window(win3)
        eq(win3, tab2:get_window())
      end)
    end)

    describe('{get,set,del}_var', function()
      it('works', function()
        local curtab = nvim.get_current_tabpage()
        curtab:set_var('lua', {1, 2, {['3'] = 1}})
        eq_items({1, 2, {['3'] = 1}}, curtab:get_var('lua'))
        eq_items({1, 2, {['3'] = 1}}, nvim.eval('t:lua'))
        eq(1, nvim.call_function('exists', {'t:lua'}))
        curtab:del_var('lua')
        eq(0, nvim.call_function('exists', {'t:lua'}))
      end)
    end)

    describe('is_valid', function()
      it('works', function()
        nvim.command('tabnew')
        local tab = nvim.get_tabpages()[2]
        nvim.set_current_tabpage(tab)
        assert.is_true(tab:is_valid())
        nvim.command('tabclose')
        assert.is_true(not tab:is_valid())
      end)
    end)
  end)
end)
