require('test.asserts')
local Nvim = require('nvim.nvim')

describe('#integration #Nvim test', function()
  local nvim, eq, eq_err, eq_items
  before_each(function()
    nvim = Nvim.new_from_process()
    eq = function(...) 
      local arg = {...}
      return assert.equal(unpack(arg)) end
    eq_err = function(expected_err, _, err)
      return assert.equal(expected_err, err) 
    end
    eq_items = function(expected, res, i_mode, kv_mode) return 
      assert.contains_same_items(expected, res, i_mode, kv_mode)
    end
  end)
  describe('#Buffer', function()
    local buffer
    before_each(function()
      buffer = nvim.get_current_buf()
    end)
    it('can return current_buffer', function()
      assert.starts_with(tostring(buffer), 'Buffer%[nvim ext type%]:')
    end)

    describe('line_count, set_lines and deleting lines using set_lines', function()
      it('line_count, set_lines and delete lines using set_lines', function()
        eq(buffer:line_count(), 1)
        buffer:set_lines(1, 2, false, {'line'})
        eq(buffer:line_count(), 2)
        buffer:set_lines(2, 3, false, {'line'})
        eq(buffer:line_count(), 3)
        buffer:set_lines(2, 3, true, {})
        eq(buffer:line_count(), 2)
        buffer:set_lines(1, 2, true, {})
        buffer:set_lines(0, 1, true, {})
        -- There's always at least one line
        eq(buffer:line_count(), 1)
      end)
    end)

    describe('{get,set}_lines', function()
      it('works', function()
        assert.contains_same_items({''}, buffer:get_lines(0, 1, true, false))    
        buffer:set_lines(0, 1, false, {'line1'})
        assert.contains_same_items({'line1'}, buffer:get_lines(0, 1, true, false))
        buffer:set_lines(1, 2, false, {'line2'})
        assert.contains_same_items({'line2'}, buffer:get_lines(1, 2, true, false))
        buffer:set_lines(0, 2, true, {})
        assert.contains_same_items({''}, buffer:get_lines(0, 1, true, false))    
      end)

      it('get_lines: out-of-bounds is an error', function()
        buffer:set_lines(0, 1, true, 'line1.a')
        local _, err = buffer:get_lines(1, 2,  true, false)
        eq('Index out of bounds', err)
      end)

      it('set_lines: out-of-bounds is an error', function()
        buffer:set_lines(0, 1, false, {'line1.a'})
        eq_err('Index out of bounds', buffer:set_lines(2, 3, true,  {'line2.b'}))
        eq_err('Index out of bounds', buffer:set_lines(-2, -3, true, {'line2.b'}))
        eq_err('Index out of bounds', buffer:set_lines(1, 2, true, {'line2.b'}))
        assert.is_nil(buffer:set_lines(1, 2, false, {'line2.b'}))
      end)

      it('can handle NULs', function()
        buffer:set_lines(0, 1, true, {'ab\0cd'})
        eq_items({'ab\0cd'}, buffer:get_lines(0, 1, true, false))
      end)
    end)

    describe('{get,set}_lines', function()
      it('has correct line_count when inserting and deleting', function()
        eq(1, buffer:line_count())
        buffer:set_lines(-1, -1, true, {'line'})
        eq(2, buffer:line_count())
        buffer:set_lines(-1, -1, true, {'line'})
        eq(3, buffer:line_count())
        buffer:set_lines(-2, -1, true, {})
        eq(2, buffer:line_count())
        buffer:set_lines(-2, -1, true, {})
        buffer:set_lines(-2, -1, true, {})
        -- There's always at least one line
        eq(1, buffer:line_count())
      end)

      it('can get, set and delete a single line', function()
        eq_items({''}, buffer:get_lines(0, 1, true))
        buffer:set_lines(0, 1, true, {'line1'})
        eq_items({'line1'}, buffer:get_lines(0, 1, true))
        buffer:set_lines(0, 1, true, {'line2'})
        eq_items({'line2'}, buffer:get_lines(0, 1, true))
        buffer:set_lines(0, 1, true, {})
        eq_items({''}, buffer:get_lines(0, 1, true))
      end)

      it('can get a single line with strict indexing', function()
        buffer:set_lines(0, 1, true, {'line1.a'})
        eq(1, buffer:line_count()) -- sanity
        eq_err('Index out of bounds', buffer:get_lines(1, 2, true))
        eq_err('Index out of bounds', buffer:get_lines(-3, -2, true))
      end)

      it('can get a single line with non-strict indexing', function()
        buffer:set_lines(0, 1, true, {'line1.a'})
        eq(1, buffer:line_count()) -- sanity
        eq_items({}, buffer:get_lines(1, 2, false))
        eq_items({}, buffer:get_lines(-3, -2, false))
      end)

      it('can set and delete a single line with strict indexing', function()
        buffer:set_lines(0, 1, true, {'line1.a'})
        eq_err('Index out of bounds', buffer:set_lines(1, 2, true, {'line1.b'}))
        eq_err('Index out of bounds', buffer:set_lines(-3, -2, true, {'line1.c'}))
        eq_items({'line1.a'}, buffer:get_lines(0, -1, true))
        eq_err('Index out of bounds', buffer:set_lines(1, 2, true, {}))
        eq_err('Index out of bounds', buffer:set_lines(-3, -2, true, {}))
        eq_items({'line1.a'}, buffer:get_lines(0, -1, true))
      end)

      it('can set and delete a single line with non-strict indexing', function()
        buffer:set_lines(0, 1, true, {'line1.a'})
        buffer:set_lines(1, 2, false, {'line1.b'})
        buffer:set_lines(-4, -3, false, {'line1.c'})
        eq_items({'line1.c', 'line1.a', 'line1.b'}, buffer:get_lines(0, -1, true))
        buffer:set_lines(3, 4, false, {})
        buffer:set_lines(-5, -4, false, {})
        eq_items({'line1.c', 'line1.a', 'line1.b'}, buffer:get_lines(0, -1, true))
      end)

      it('can handle NULs', function()
        buffer:set_lines(0, 1, true, {'ab\0cd'})
        eq_items({'ab\0cd'}, buffer:get_lines(0, -1, true))
      end)

      it('works with multiple lines', function()
        eq_items({''}, buffer:get_lines(0, -1, true))
        -- Replace buffer
        for _, mode in pairs({false, true}) do
          buffer:set_lines(0, -1, mode, {'a', 'b', 'c'})
          eq_items({'a', 'b', 'c'}, buffer:get_lines(0, -1, mode))
          eq_items({'b', 'c'}, buffer:get_lines(1, -1, mode))
          eq_items({'b'}, buffer:get_lines(1, 2, mode))
          eq_items({}, buffer:get_lines(1, 1, mode))
          eq_items({'a', 'b'}, buffer:get_lines(0, -2, mode))
          eq_items({'b'}, buffer:get_lines(1, -2, mode))
          eq_items({'b', 'c'}, buffer:get_lines(-3, -1, mode))
          buffer:set_lines(1, 2, mode, {'a', 'b', 'c'})
          eq_items({'a', 'a', 'b', 'c', 'c'}, buffer:get_lines(0, -1, mode))
          buffer:set_lines(-2, -1, mode, {'a', 'b', 'c'})
          eq_items({'a', 'a', 'b', 'c', 'a', 'b', 'c'},
            buffer:get_lines(0, -1, mode))
          buffer:set_lines(0, -4, mode, {})
          eq_items({'a', 'b', 'c'}, buffer:get_lines(0, -1, mode))
          buffer:set_lines(0, -1, mode, {})
          eq_items({''}, buffer:get_lines(0, -1, mode))
        end
      end)

      it('can get line ranges with non-strict indexing', function()
        buffer:set_lines(0, -1, true, {'a', 'b', 'c'})
        eq_items({'a', 'b', 'c'}, buffer:get_lines(0, -1, true)) --sanity

        eq_items({}, buffer:get_lines(3, 4, false))
        eq_items({}, buffer:get_lines(3, 10, false))
        eq_items({}, buffer:get_lines(-5, -5, false))
        eq_items({}, buffer:get_lines(3, -1, false))
        eq_items({}, buffer:get_lines(-3, -4, false))
      end)

      it('can get line ranges with strict indexing', function()
        buffer:set_lines(0, -1, true, {'a', 'b', 'c'})
        eq_items({'a', 'b', 'c'}, buffer:get_lines(0, -1, true)) --sanity

        eq_err('Index out of bounds', buffer:get_lines(3, 4, true))
        eq_err('Index out of bounds', buffer:get_lines(3, 10, true))
        eq_err('Index out of bounds', buffer:get_lines(-5, -5, true))
        -- empty or inverted ranges are not errors
        eq_items({}, buffer:get_lines(3, -1, true))
        eq_items({}, buffer:get_lines(-3, -4, true))
      end)

      it('set_line_slice: out-of-bounds can extend past end', function()
        buffer:set_lines(0, -1, true, {'a', 'b', 'c'})
        eq_items({'a', 'b', 'c'}, buffer:get_lines(0, -1, true)) --sanity

        eq_items({'c'}, buffer:get_lines(-2, 5, false))
        eq_items({'a', 'b', 'c'}, buffer:get_lines(0, 6, false))
        eq_err('Index out of bounds', buffer:set_lines(4, 6, true, {'d'}))
        buffer:set_lines(4, 6, false, {'d'})
        eq_items({'a', 'b', 'c', 'd'}, buffer:get_lines(0, -1, true))
        eq_err('Index out of bounds', buffer:set_lines(-6, -6, true, {'e'}))
        buffer:set_lines(-6, -6, false, {'e'})
        eq_items({'e', 'a', 'b', 'c', 'd'}, buffer:get_lines(0, -1, true))
      end)
    end)

    describe('{get,set,del}_var', function()
      it('works', function()
        buffer:set_var('lua', {1, 2, {['3'] = 1}})
        eq_items({1, 2, {['3'] = 1}}, buffer:get_var('lua'))
        eq_items({1, 2, {['3'] = 1}}, nvim.eval('b:lua'))
        eq(1, nvim.call_function('exists', {'b:lua'}))
        buffer:del_var('lua')
        eq(0, nvim.call_function('exists', {'b:lua'}))
      end)
    end)

    describe('{get,set}_option', function()
      it('works', function()
        eq(8, buffer:get_option('shiftwidth'))
        buffer:set_option('shiftwidth', 4)
        eq(4, buffer:get_option('shiftwidth'))
        -- global-local option
        buffer:set_option('define', 'test')
        eq('test', buffer:get_option('define'))
        -- Doesn't change the global value
        eq([[^\s*#\s*define]], nvim.get_option('define'))
      end)
    end)

    describe('{get,set}_name', function()
      it('works', function()
        nvim.command('new')
        local new_buffer = nvim.get_current_buf()
        eq('', new_buffer:get_name())
        local new_name = nvim.eval('resolve(tempname())')
        new_buffer:set_name(new_name)
        eq(new_name, new_buffer:get_name())
        nvim.command('w!')
        local f = io.open(new_name)
        assert.is_not_nil(f)
        f:close()
        os.remove(new_name)
      end)
    end)

    describe('is_valid', function()
      it('works', function()
        nvim.command('new')
        local b = nvim.get_current_buf()
        assert.is_true(b:is_valid())
        nvim.command('bw!')
        assert.is_true(not b:is_valid())
      end)
    end)

    describe('get_mark', function()
      it('works', function()
        buffer:set_lines(0, 1, true, {'a', 'bit of', 'text'})
        local win = nvim.get_current_win()
        win:set_cursor({3, 4})
        nvim.command('mark V')
        eq_items({3, 0}, buffer:get_mark('V'))
      end)
    end)
  end)
  describe('#Tabpage', function()
    describe('get_windows and get_window', function()
      it('works', function()
        nvim.command('tabnew')
        nvim.command('vsplit')
        local tab1, tab2 = unpack(nvim.list_tabpages())
        local win1, win2, win3 = unpack(nvim.list_wins())
        eq_items({win1},  tab1:list_wins())
        eq_items({win2, win3},  tab2:list_wins())
        eq(win2, tab2:get_win())
        nvim.set_current_win(win3)
        eq(win3, tab2:get_win())
      end)
    end)

    describe('{get,set,del}_var', function()
      it('works', function()
        local curtab = nvim.get_current_tabpage()
        curtab:set_var('lua', {1, 2, {['3'] = 1}})
        eq_items({1, 2, {['3'] = 1}}, curtab:get_var('lua'))
        eq_items({1, 2, {['3'] = 1}}, nvim.eval('t:lua'))
        eq(1, nvim.call_function('exists', {'t:lua'}))
        curtab:del_var('lua')
        eq(0, nvim.call_function('exists', {'t:lua'}))
      end)
    end)

    describe('is_valid', function()
      it('works', function()
        nvim.command('tabnew')
        local tab = nvim.list_tabpages()[2]
        nvim.set_current_tabpage(tab)
        assert.is_true(tab:is_valid())
        nvim.command('tabclose')
        assert.is_true(not tab:is_valid())
      end)
    end)
  end)
end)
