require('test.asserts')
local Nvim = require('nvim.nvim')

describe('#integration #Nvim test', function()
  local nvim, eq, eq_err, eq_items
  before_each(function()
    nvim = Nvim.new_from_process()
    eq = function(...) 
      local arg = {...}
      return assert.equal(unpack(arg)) end
    eq_err = function(expected_err, _, err)
      return assert.equal(expected_err, err[2]) 
    end
    eq_items = function(expected, res, i_mode, kv_mode) return 
      assert.contains_same_items(expected, res, i_mode, kv_mode)
    end
  end)
  describe('#Buffer', function()
    local buff
    before_each(function()
      buff = nvim.nvim_get_current_buf()
    end)
    it('can return current_buffer', function()
      assert.is_not_nil(buff)
    end)

    describe('line_count, set_lines and deleting lines using set_lines', function()
      it('line_count, set_lines and delete lines using set_lines', function()
        eq(nvim.nvim_buf_line_count(buff), 1)
        nvim.nvim_buf_set_lines(buff, 1, 2, false, {'line'})
        eq(nvim.nvim_buf_line_count(buff), 2)
        nvim.nvim_buf_set_lines(buff, 2, 3, false, {'line'})
        eq(nvim.nvim_buf_line_count(buff), 3)
        nvim.nvim_buf_set_lines(buff, 2, 3, true, {})
        eq(nvim.nvim_buf_line_count(buff), 2)
        nvim.nvim_buf_set_lines(buff, 1, 2, true, {})
        nvim.nvim_buf_set_lines(buff, 0, 1, true, {})
        -- There's always at least one line
        eq(nvim.nvim_buf_line_count(buff), 1)
      end)
    end)

    describe('{get,set}_lines', function()
      it('works', function()
        assert.contains_same_items({''}, nvim.nvim_buf_get_lines(buff, 0, 1, true))    
        nvim.nvim_buf_set_lines(buff, 0, 1, false, {'line1'})
        assert.contains_same_items({'line1'}, nvim.nvim_buf_get_lines(buff, 0, 1, true))
        nvim.nvim_buf_set_lines(buff, 1, 2, false, {'line2'})
        assert.contains_same_items({'line2'}, nvim.nvim_buf_get_lines(buff, 1, 2, true))
        nvim.nvim_buf_set_lines(buff, 0, 2, true, {})
        assert.contains_same_items({''}, nvim.nvim_buf_get_lines(buff, 0, 1, true))    
      end)

      it('get_lines: out-of-bounds is an error', function()
        nvim.nvim_buf_set_lines(buff, 0, 1, true, 'line1.a')
        local _, err = nvim.nvim_buf_get_lines(buff, 1, 2,  true)
        eq('Index out of bounds', err[2])
      end)

      it('#set_lines: out-of-bounds is an error', function()
        nvim.nvim_buf_set_lines(buff, 0, 1, false, {'line1.a'})
        eq_err('Index out of bounds', nvim.nvim_buf_set_lines(buff, 2, 3, true,  {'line2.b'}))
        eq_err('Index out of bounds', nvim.nvim_buf_set_lines(buff, -2, -3, true, {'line2.b'}))
        eq_err('Index out of bounds', nvim.nvim_buf_set_lines(buff, 1, 2, true, {'line2.b'}))
        -- "void" is represendetd as mpack.NIL value!
        assert.is_not_nil(nvim.nvim_buf_set_lines(buff, 1, 2, false, {'line2.b'}))
      end)

      it('can handle NULs', function()
        nvim.nvim_buf_set_lines(buff, 0, 1, true, {'ab\0cd'})
        eq_items({'ab\0cd'}, nvim.nvim_buf_get_lines(buff, 0, 1, true))
      end)
    end)

    describe('{get,set}_lines', function()
      it('has correct line_count when inserting and deleting', function()
        eq(1, nvim.nvim_buf_line_count(buff))
        nvim.nvim_buf_set_lines(buff, -1, -1, true, {'line'})
        eq(2, nvim.nvim_buf_line_count(buff))
        nvim.nvim_buf_set_lines(buff, -1, -1, true, {'line'})
        eq(3, nvim.nvim_buf_line_count(buff))
        nvim.nvim_buf_set_lines(buff, -2, -1, true, {})
        eq(2, nvim.nvim_buf_line_count(buff))
        nvim.nvim_buf_set_lines(buff, -2, -1, true, {})
        nvim.nvim_buf_set_lines(buff, -2, -1, true, {})
        -- There's always at least one line
        eq(1, nvim.nvim_buf_line_count(buff))
      end)

      it('can get, set and delete a single line', function()
        eq_items({''}, nvim.nvim_buf_get_lines(buff, 0, 1, true))
        nvim.nvim_buf_set_lines(buff, 0, 1, true, {'line1'})
        eq_items({'line1'}, nvim.nvim_buf_get_lines(buff, 0, 1, true))
        nvim.nvim_buf_set_lines(buff, 0, 1, true, {'line2'})
        eq_items({'line2'}, nvim.nvim_buf_get_lines(buff, 0, 1, true))
        nvim.nvim_buf_set_lines(buff, 0, 1, true, {})
        eq_items({''}, nvim.nvim_buf_get_lines(buff, 0, 1, true))
      end)

      it('can get a single line with strict indexing', function()
        nvim.nvim_buf_set_lines(buff, 0, 1, true, {'line1.a'})
        eq(1, nvim.nvim_buf_line_count(buff)) -- sanity
        eq_err('Index out of bounds', nvim.nvim_buf_get_lines(buff, 1, 2, true))
        eq_err('Index out of bounds', nvim.nvim_buf_get_lines(buff, -3, -2, true))
      end)

      it('can get a single line with non-strict indexing', function()
        nvim.nvim_buf_set_lines(buff, 0, 1, true, {'line1.a'})
        eq(1, nvim.nvim_buf_line_count(buff)) -- sanity
        eq_items({}, nvim.nvim_buf_get_lines(buff, 1, 2, false))
        eq_items({}, nvim.nvim_buf_get_lines(buff, -3, -2, false))
      end)

      it('can set and delete a single line with strict indexing', function()
        nvim.nvim_buf_set_lines(buff, 0, 1, true, {'line1.a'})
        eq_err('Index out of bounds', nvim.nvim_buf_set_lines(buff, 1, 2, true, {'line1.b'}))
        eq_err('Index out of bounds', nvim.nvim_buf_set_lines(buff, -3, -2, true, {'line1.c'}))
        eq_items({'line1.a'}, nvim.nvim_buf_get_lines(buff, 0, -1, true))
        eq_err('Index out of bounds', nvim.nvim_buf_set_lines(buff, 1, 2, true, {}))
        eq_err('Index out of bounds', nvim.nvim_buf_set_lines(buff, -3, -2, true, {}))
        eq_items({'line1.a'}, nvim.nvim_buf_get_lines(buff, 0, -1, true))
      end)

      it('can set and delete a single line with non-strict indexing', function()
        nvim.nvim_buf_set_lines(buff, 0, 1, true, {'line1.a'})
        nvim.nvim_buf_set_lines(buff, 1, 2, false, {'line1.b'})
        nvim.nvim_buf_set_lines(buff, -4, -3, false, {'line1.c'})
        eq_items({'line1.c', 'line1.a', 'line1.b'}, nvim.nvim_buf_get_lines(buff, 0, -1, true))
        nvim.nvim_buf_set_lines(buff, 3, 4, false, {})
        nvim.nvim_buf_set_lines(buff, -5, -4, false, {})
        eq_items({'line1.c', 'line1.a', 'line1.b'}, nvim.nvim_buf_get_lines(buff, 0, -1, true))
      end)

      it('can handle NULs', function()
        nvim.nvim_buf_set_lines(buff, 0, 1, true, {'ab\0cd'})
        eq_items({'ab\0cd'}, nvim.nvim_buf_get_lines(buff, 0, -1, true))
      end)

      it('works with multiple lines', function()
        eq_items({''}, nvim.nvim_buf_get_lines(buff, 0, -1, true))
        -- Replace buffer
        for _, mode in pairs({false, true}) do
          nvim.nvim_buf_set_lines(buff, 0, -1, mode, {'a', 'b', 'c'})
          eq_items({'a', 'b', 'c'}, nvim.nvim_buf_get_lines(buff, 0, -1, mode))
          eq_items({'b', 'c'}, nvim.nvim_buf_get_lines(buff, 1, -1, mode))
          eq_items({'b'}, nvim.nvim_buf_get_lines(buff, 1, 2, mode))
          eq_items({}, nvim.nvim_buf_get_lines(buff, 1, 1, mode))
          eq_items({'a', 'b'}, nvim.nvim_buf_get_lines(buff, 0, -2, mode))
          eq_items({'b'}, nvim.nvim_buf_get_lines(buff, 1, -2, mode))
          eq_items({'b', 'c'}, nvim.nvim_buf_get_lines(buff, -3, -1, mode))
          nvim.nvim_buf_set_lines(buff, 1, 2, mode, {'a', 'b', 'c'})
          eq_items({'a', 'a', 'b', 'c', 'c'}, nvim.nvim_buf_get_lines(buff, 0, -1, mode))
          nvim.nvim_buf_set_lines(buff, -2, -1, mode, {'a', 'b', 'c'})
          eq_items({'a', 'a', 'b', 'c', 'a', 'b', 'c'},
            nvim.nvim_buf_get_lines(buff, 0, -1, mode))
          nvim.nvim_buf_set_lines(buff, 0, -4, mode, {})
          eq_items({'a', 'b', 'c'}, nvim.nvim_buf_get_lines(buff, 0, -1, mode))
          nvim.nvim_buf_set_lines(buff, 0, -1, mode, {})
          eq_items({''}, nvim.nvim_buf_get_lines(buff, 0, -1, mode))
        end
      end)

      it('can get line ranges with non-strict indexing', function()
        nvim.nvim_buf_set_lines(buff, 0, -1, true, {'a', 'b', 'c'})
        eq_items({'a', 'b', 'c'}, nvim.nvim_buf_get_lines(buff, 0, -1, true)) --sanity
        eq_items({}, nvim.nvim_buf_get_lines(buff, 3, 4, false))
        eq_items({}, nvim.nvim_buf_get_lines(buff, 3, 10, false))
        eq_items({}, nvim.nvim_buf_get_lines(buff, -5, -5, false))
        eq_items({}, nvim.nvim_buf_get_lines(buff, 3, -1, false))
        eq_items({}, nvim.nvim_buf_get_lines(buff, -3, -4, false))
      end)

      it('can get line ranges with strict indexing', function()
        nvim.nvim_buf_set_lines(buff, 0, -1, true, {'a', 'b', 'c'})
        eq_items({'a', 'b', 'c'}, nvim.nvim_buf_get_lines(buff, 0, -1, true)) --sanity

        eq_err('Index out of bounds', nvim.nvim_buf_get_lines(buff, 3, 4, true))
        eq_err('Index out of bounds', nvim.nvim_buf_get_lines(buff, 3, 10, true))
        eq_err('Index out of bounds', nvim.nvim_buf_get_lines(buff, -5, -5, true))
        -- empty or inverted ranges are not errors
        eq_items({}, nvim.nvim_buf_get_lines(buff, 3, -1, true))
        eq_items({}, nvim.nvim_buf_get_lines(buff, -3, -4, true))
      end)

      it('set_line_slice: out-of-bounds can extend past end', function()
        nvim.nvim_buf_set_lines(buff, 0, -1, true, {'a', 'b', 'c'})
        eq_items({'a', 'b', 'c'}, nvim.nvim_buf_get_lines(buff, 0, -1, true)) --sanity

        eq_items({'c'}, nvim.nvim_buf_get_lines(buff, -2, 5, false))
        eq_items({'a', 'b', 'c'}, nvim.nvim_buf_get_lines(buff, 0, 6, false))
        eq_err('Index out of bounds', nvim.nvim_buf_set_lines(buff, 4, 6, true, {'d'}))
        nvim.nvim_buf_set_lines(buff, 4, 6, false, {'d'})
        eq_items({'a', 'b', 'c', 'd'}, nvim.nvim_buf_get_lines(buff, 0, -1, true))
        eq_err('Index out of bounds', nvim.nvim_buf_set_lines(buff, -6, -6, true, {'e'}))
        nvim.nvim_buf_set_lines(buff, -6, -6, false, {'e'})
        eq_items({'e', 'a', 'b', 'c', 'd'}, nvim.nvim_buf_get_lines(buff, 0, -1, true))
      end)
    end)

    describe('{get,set,del}_var', function()
      it('works', function()
        nvim.nvim_buf_set_var(buff, 'lua', {1, 2, {['3'] = 1}})
        eq_items({1, 2, {['3'] = 1}}, nvim.nvim_buf_get_var(buff, 'lua'))
        eq_items({1, 2, {['3'] = 1}}, nvim.nvim_eval('b:lua'))
        eq(1, nvim.nvim_call_function('exists', {'b:lua'}))
        nvim.nvim_buf_del_var(buff, 'lua')
        eq(0, nvim.nvim_call_function('exists', {'b:lua'}))
      end)
    end)

    describe('{get,set}_option', function()
      it('works', function()
        eq(8, nvim.nvim_buf_get_option(buff, 'shiftwidth'))
        nvim.nvim_buf_set_option(buff, 'shiftwidth', 4)
        eq(4, nvim.nvim_buf_get_option(buff, 'shiftwidth'))
        -- global-local option
        nvim.nvim_buf_set_option(buff, 'define', 'test')
        eq('test', nvim.nvim_buf_get_option(buff, 'define'))
        -- Doesn't change the global value
        eq([[^\s*#\s*define]], nvim.nvim_get_option('define'))
      end)
    end)

    describe('{get,set}_name', function()
      it('works', function()
        nvim.nvim_command('new')
        local new_buffer = nvim.nvim_get_current_buf()
        eq('', nvim.nvim_buf_get_name(new_buffer))
        local new_name = nvim.nvim_eval('resolve(tempname())')
        nvim.nvim_buf_set_name(new_buffer, new_name)
        eq(new_name, nvim.nvim_buf_get_name(new_buffer))
        nvim.nvim_command('w!')
        local f = io.open(new_name)
        assert.is_not_nil(f)
        f:close()
        os.remove(new_name)
      end)
    end)

    describe('is_valid', function()
      it('works', function()
        nvim.nvim_command('new')
        local b = nvim.nvim_get_current_buf()
        assert.is_true(nvim.nvim_buf_is_valid(b))
        nvim.nvim_command('bw!')
        assert.is_true(not nvim.nvim_buf_is_valid(b))
      end)
    end)

    describe('get_mark', function()
      it('works', function()
        nvim.nvim_buf_set_lines(buff, 0, 1, true, {'a', 'bit of', 'text'})
        local win = nvim.nvim_get_current_win()
        nvim.nvim_win_set_cursor(win, {3, 4})
        nvim.nvim_command('mark V')
        eq_items({3, 0}, nvim.nvim_buf_get_mark(buff, 'V'))
      end)
    end)
  end)
  describe('#Tabpage', function()
    describe('get_windows and get_window', function()
      it('works', function()
        nvim.nvim_command('tabnew')
        nvim.nvim_command('vsplit')
        local tab1, tab2 = unpack(nvim.nvim_list_tabpages())
        local win1, win2, win3 = unpack(nvim.nvim_list_wins())
        eq_items({win1},  nvim.nvim_tabpage_list_wins(tab1))
        eq_items({win2, win3}, nvim.nvim_tabpage_list_wins(tab2))
        i = require "inspect"
        eq(win2.id, nvim.nvim_tabpage_get_win(tab2).id)
        nvim.nvim_set_current_win(win3)
        eq(win3.id, nvim.nvim_tabpage_get_win(tab2).id)
      end)
    end)

    describe('{get,set,del}_var', function()
      it('works', function()
        local curtab = nvim.nvim_get_current_tabpage()
        nvim.nvim_tabpage_set_var(curtab, 'lua', {1, 2, {['3'] = 1}})
        eq_items({1, 2, {['3'] = 1}}, nvim.nvim_tabpage_get_var(curtab, 'lua'))
        eq_items({1, 2, {['3'] = 1}}, nvim.nvim_eval('t:lua'))
        eq(1, nvim.nvim_call_function('exists', {'t:lua'}))
        nvim.nvim_tabpage_del_var(curtab, 'lua')
        eq(0, nvim.nvim_call_function('exists', {'t:lua'}))
      end)
    end)

    describe('is_valid', function()
      it('works', function()
        nvim.nvim_command('tabnew')
        local tab = nvim.nvim_list_tabpages()[2]
        nvim.nvim_set_current_tabpage(tab)
        assert.is_true(nvim.nvim_tabpage_is_valid(tab))
        nvim.nvim_command('tabclose')
        assert.is_true(not nvim.nvim_tabpage_is_valid(tab))
      end)
    end)
  end)
end)
